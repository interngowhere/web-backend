// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/interngowhere/web-backend/ent/comment"
	"github.com/interngowhere/web-backend/ent/commentkudo"
	"github.com/interngowhere/web-backend/ent/moderator"
	"github.com/interngowhere/web-backend/ent/predicate"
	"github.com/interngowhere/web-backend/ent/tag"
	"github.com/interngowhere/web-backend/ent/thread"
	"github.com/interngowhere/web-backend/ent/threadkudo"
	"github.com/interngowhere/web-backend/ent/topic"
	"github.com/interngowhere/web-backend/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment     = "Comment"
	TypeCommentKudo = "CommentKudo"
	TypeModerator   = "Moderator"
	TypeTag         = "Tag"
	TypeThread      = "Thread"
	TypeThreadKudo  = "ThreadKudo"
	TypeTopic       = "Topic"
	TypeUser        = "User"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	parent_id              *int
	addparent_id           *int
	content                *string
	modified_at            *time.Time
	created_at             *time.Time
	clearedFields          map[string]struct{}
	threads                *int
	clearedthreads         bool
	comment_authors        *uuid.UUID
	clearedcomment_authors bool
	kudoed_users           map[uuid.UUID]struct{}
	removedkudoed_users    map[uuid.UUID]struct{}
	clearedkudoed_users    bool
	done                   bool
	oldValue               func(context.Context) (*Comment, error)
	predicates             []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *CommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
}

// SetModifiedAt sets the "modified_at" field.
func (m *CommentMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *CommentMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (m *CommentMutation) ClearModifiedAt() {
	m.modified_at = nil
	m.clearedFields[comment.FieldModifiedAt] = struct{}{}
}

// ModifiedAtCleared returns if the "modified_at" field was cleared in this mutation.
func (m *CommentMutation) ModifiedAtCleared() bool {
	_, ok := m.clearedFields[comment.FieldModifiedAt]
	return ok
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *CommentMutation) ResetModifiedAt() {
	m.modified_at = nil
	delete(m.clearedFields, comment.FieldModifiedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *CommentMutation) SetCreatedBy(u uuid.UUID) {
	m.comment_authors = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *CommentMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.comment_authors
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *CommentMutation) ResetCreatedBy() {
	m.comment_authors = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetThreadsID sets the "threads" edge to the Thread entity by id.
func (m *CommentMutation) SetThreadsID(id int) {
	m.threads = &id
}

// ClearThreads clears the "threads" edge to the Thread entity.
func (m *CommentMutation) ClearThreads() {
	m.clearedthreads = true
}

// ThreadsCleared reports if the "threads" edge to the Thread entity was cleared.
func (m *CommentMutation) ThreadsCleared() bool {
	return m.clearedthreads
}

// ThreadsID returns the "threads" edge ID in the mutation.
func (m *CommentMutation) ThreadsID() (id int, exists bool) {
	if m.threads != nil {
		return *m.threads, true
	}
	return
}

// ThreadsIDs returns the "threads" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadsID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ThreadsIDs() (ids []int) {
	if id := m.threads; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThreads resets all changes to the "threads" edge.
func (m *CommentMutation) ResetThreads() {
	m.threads = nil
	m.clearedthreads = false
}

// SetCommentAuthorsID sets the "comment_authors" edge to the User entity by id.
func (m *CommentMutation) SetCommentAuthorsID(id uuid.UUID) {
	m.comment_authors = &id
}

// ClearCommentAuthors clears the "comment_authors" edge to the User entity.
func (m *CommentMutation) ClearCommentAuthors() {
	m.clearedcomment_authors = true
	m.clearedFields[comment.FieldCreatedBy] = struct{}{}
}

// CommentAuthorsCleared reports if the "comment_authors" edge to the User entity was cleared.
func (m *CommentMutation) CommentAuthorsCleared() bool {
	return m.clearedcomment_authors
}

// CommentAuthorsID returns the "comment_authors" edge ID in the mutation.
func (m *CommentMutation) CommentAuthorsID() (id uuid.UUID, exists bool) {
	if m.comment_authors != nil {
		return *m.comment_authors, true
	}
	return
}

// CommentAuthorsIDs returns the "comment_authors" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentAuthorsID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) CommentAuthorsIDs() (ids []uuid.UUID) {
	if id := m.comment_authors; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommentAuthors resets all changes to the "comment_authors" edge.
func (m *CommentMutation) ResetCommentAuthors() {
	m.comment_authors = nil
	m.clearedcomment_authors = false
}

// AddKudoedUserIDs adds the "kudoed_users" edge to the User entity by ids.
func (m *CommentMutation) AddKudoedUserIDs(ids ...uuid.UUID) {
	if m.kudoed_users == nil {
		m.kudoed_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.kudoed_users[ids[i]] = struct{}{}
	}
}

// ClearKudoedUsers clears the "kudoed_users" edge to the User entity.
func (m *CommentMutation) ClearKudoedUsers() {
	m.clearedkudoed_users = true
}

// KudoedUsersCleared reports if the "kudoed_users" edge to the User entity was cleared.
func (m *CommentMutation) KudoedUsersCleared() bool {
	return m.clearedkudoed_users
}

// RemoveKudoedUserIDs removes the "kudoed_users" edge to the User entity by IDs.
func (m *CommentMutation) RemoveKudoedUserIDs(ids ...uuid.UUID) {
	if m.removedkudoed_users == nil {
		m.removedkudoed_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.kudoed_users, ids[i])
		m.removedkudoed_users[ids[i]] = struct{}{}
	}
}

// RemovedKudoedUsers returns the removed IDs of the "kudoed_users" edge to the User entity.
func (m *CommentMutation) RemovedKudoedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedkudoed_users {
		ids = append(ids, id)
	}
	return
}

// KudoedUsersIDs returns the "kudoed_users" edge IDs in the mutation.
func (m *CommentMutation) KudoedUsersIDs() (ids []uuid.UUID) {
	for id := range m.kudoed_users {
		ids = append(ids, id)
	}
	return
}

// ResetKudoedUsers resets all changes to the "kudoed_users" edge.
func (m *CommentMutation) ResetKudoedUsers() {
	m.kudoed_users = nil
	m.clearedkudoed_users = false
	m.removedkudoed_users = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.parent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.modified_at != nil {
		fields = append(fields, comment.FieldModifiedAt)
	}
	if m.comment_authors != nil {
		fields = append(fields, comment.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, comment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldParentID:
		return m.ParentID()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldModifiedAt:
		return m.ModifiedAt()
	case comment.FieldCreatedBy:
		return m.CreatedBy()
	case comment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	case comment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case comment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case comment.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case comment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.addparent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldModifiedAt) {
		fields = append(fields, comment.FieldModifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldModifiedAt:
		m.ClearModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case comment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case comment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.threads != nil {
		edges = append(edges, comment.EdgeThreads)
	}
	if m.comment_authors != nil {
		edges = append(edges, comment.EdgeCommentAuthors)
	}
	if m.kudoed_users != nil {
		edges = append(edges, comment.EdgeKudoedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeThreads:
		if id := m.threads; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeCommentAuthors:
		if id := m.comment_authors; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeKudoedUsers:
		ids := make([]ent.Value, 0, len(m.kudoed_users))
		for id := range m.kudoed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedkudoed_users != nil {
		edges = append(edges, comment.EdgeKudoedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeKudoedUsers:
		ids := make([]ent.Value, 0, len(m.removedkudoed_users))
		for id := range m.removedkudoed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedthreads {
		edges = append(edges, comment.EdgeThreads)
	}
	if m.clearedcomment_authors {
		edges = append(edges, comment.EdgeCommentAuthors)
	}
	if m.clearedkudoed_users {
		edges = append(edges, comment.EdgeKudoedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeThreads:
		return m.clearedthreads
	case comment.EdgeCommentAuthors:
		return m.clearedcomment_authors
	case comment.EdgeKudoedUsers:
		return m.clearedkudoed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeThreads:
		m.ClearThreads()
		return nil
	case comment.EdgeCommentAuthors:
		m.ClearCommentAuthors()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeThreads:
		m.ResetThreads()
		return nil
	case comment.EdgeCommentAuthors:
		m.ResetCommentAuthors()
		return nil
	case comment.EdgeKudoedUsers:
		m.ResetKudoedUsers()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CommentKudoMutation represents an operation that mutates the CommentKudo nodes in the graph.
type CommentKudoMutation struct {
	config
	op             Op
	typ            string
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	comment        *int
	clearedcomment bool
	done           bool
	oldValue       func(context.Context) (*CommentKudo, error)
	predicates     []predicate.CommentKudo
}

var _ ent.Mutation = (*CommentKudoMutation)(nil)

// commentkudoOption allows management of the mutation configuration using functional options.
type commentkudoOption func(*CommentKudoMutation)

// newCommentKudoMutation creates new mutation for the CommentKudo entity.
func newCommentKudoMutation(c config, op Op, opts ...commentkudoOption) *CommentKudoMutation {
	m := &CommentKudoMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentKudo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentKudoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentKudoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *CommentKudoMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentKudoMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentKudoMutation) ResetUserID() {
	m.user = nil
}

// SetCommentID sets the "comment_id" field.
func (m *CommentKudoMutation) SetCommentID(i int) {
	m.comment = &i
}

// CommentID returns the value of the "comment_id" field in the mutation.
func (m *CommentKudoMutation) CommentID() (r int, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentID resets all changes to the "comment_id" field.
func (m *CommentKudoMutation) ResetCommentID() {
	m.comment = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentKudoMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[commentkudo.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentKudoMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentKudoMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentKudoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearComment clears the "comment" edge to the Comment entity.
func (m *CommentKudoMutation) ClearComment() {
	m.clearedcomment = true
	m.clearedFields[commentkudo.FieldCommentID] = struct{}{}
}

// CommentCleared reports if the "comment" edge to the Comment entity was cleared.
func (m *CommentKudoMutation) CommentCleared() bool {
	return m.clearedcomment
}

// CommentIDs returns the "comment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentID instead. It exists only for internal usage by the builders.
func (m *CommentKudoMutation) CommentIDs() (ids []int) {
	if id := m.comment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComment resets all changes to the "comment" edge.
func (m *CommentKudoMutation) ResetComment() {
	m.comment = nil
	m.clearedcomment = false
}

// Where appends a list predicates to the CommentKudoMutation builder.
func (m *CommentKudoMutation) Where(ps ...predicate.CommentKudo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentKudoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentKudoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentKudo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentKudoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentKudoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentKudo).
func (m *CommentKudoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentKudoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user != nil {
		fields = append(fields, commentkudo.FieldUserID)
	}
	if m.comment != nil {
		fields = append(fields, commentkudo.FieldCommentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentKudoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentkudo.FieldUserID:
		return m.UserID()
	case commentkudo.FieldCommentID:
		return m.CommentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentKudoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema CommentKudo does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentKudoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentkudo.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case commentkudo.FieldCommentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentID(v)
		return nil
	}
	return fmt.Errorf("unknown CommentKudo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentKudoMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentKudoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentKudoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommentKudo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentKudoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentKudoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentKudoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CommentKudo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentKudoMutation) ResetField(name string) error {
	switch name {
	case commentkudo.FieldUserID:
		m.ResetUserID()
		return nil
	case commentkudo.FieldCommentID:
		m.ResetCommentID()
		return nil
	}
	return fmt.Errorf("unknown CommentKudo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentKudoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, commentkudo.EdgeUser)
	}
	if m.comment != nil {
		edges = append(edges, commentkudo.EdgeComment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentKudoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commentkudo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case commentkudo.EdgeComment:
		if id := m.comment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentKudoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentKudoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentKudoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, commentkudo.EdgeUser)
	}
	if m.clearedcomment {
		edges = append(edges, commentkudo.EdgeComment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentKudoMutation) EdgeCleared(name string) bool {
	switch name {
	case commentkudo.EdgeUser:
		return m.cleareduser
	case commentkudo.EdgeComment:
		return m.clearedcomment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentKudoMutation) ClearEdge(name string) error {
	switch name {
	case commentkudo.EdgeUser:
		m.ClearUser()
		return nil
	case commentkudo.EdgeComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown CommentKudo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentKudoMutation) ResetEdge(name string) error {
	switch name {
	case commentkudo.EdgeUser:
		m.ResetUser()
		return nil
	case commentkudo.EdgeComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown CommentKudo edge %s", name)
}

// ModeratorMutation represents an operation that mutates the Moderator nodes in the graph.
type ModeratorMutation struct {
	config
	op               Op
	typ              string
	clearedFields    map[string]struct{}
	moderator        *uuid.UUID
	clearedmoderator bool
	topic            *int
	clearedtopic     bool
	done             bool
	oldValue         func(context.Context) (*Moderator, error)
	predicates       []predicate.Moderator
}

var _ ent.Mutation = (*ModeratorMutation)(nil)

// moderatorOption allows management of the mutation configuration using functional options.
type moderatorOption func(*ModeratorMutation)

// newModeratorMutation creates new mutation for the Moderator entity.
func newModeratorMutation(c config, op Op, opts ...moderatorOption) *ModeratorMutation {
	m := &ModeratorMutation{
		config:        c,
		op:            op,
		typ:           TypeModerator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModeratorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModeratorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetModeratorID sets the "moderator_id" field.
func (m *ModeratorMutation) SetModeratorID(u uuid.UUID) {
	m.moderator = &u
}

// ModeratorID returns the value of the "moderator_id" field in the mutation.
func (m *ModeratorMutation) ModeratorID() (r uuid.UUID, exists bool) {
	v := m.moderator
	if v == nil {
		return
	}
	return *v, true
}

// ResetModeratorID resets all changes to the "moderator_id" field.
func (m *ModeratorMutation) ResetModeratorID() {
	m.moderator = nil
}

// SetTopicID sets the "topic_id" field.
func (m *ModeratorMutation) SetTopicID(i int) {
	m.topic = &i
}

// TopicID returns the value of the "topic_id" field in the mutation.
func (m *ModeratorMutation) TopicID() (r int, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// ResetTopicID resets all changes to the "topic_id" field.
func (m *ModeratorMutation) ResetTopicID() {
	m.topic = nil
}

// ClearModerator clears the "moderator" edge to the User entity.
func (m *ModeratorMutation) ClearModerator() {
	m.clearedmoderator = true
	m.clearedFields[moderator.FieldModeratorID] = struct{}{}
}

// ModeratorCleared reports if the "moderator" edge to the User entity was cleared.
func (m *ModeratorMutation) ModeratorCleared() bool {
	return m.clearedmoderator
}

// ModeratorIDs returns the "moderator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModeratorID instead. It exists only for internal usage by the builders.
func (m *ModeratorMutation) ModeratorIDs() (ids []uuid.UUID) {
	if id := m.moderator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModerator resets all changes to the "moderator" edge.
func (m *ModeratorMutation) ResetModerator() {
	m.moderator = nil
	m.clearedmoderator = false
}

// ClearTopic clears the "topic" edge to the Topic entity.
func (m *ModeratorMutation) ClearTopic() {
	m.clearedtopic = true
	m.clearedFields[moderator.FieldTopicID] = struct{}{}
}

// TopicCleared reports if the "topic" edge to the Topic entity was cleared.
func (m *ModeratorMutation) TopicCleared() bool {
	return m.clearedtopic
}

// TopicIDs returns the "topic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicID instead. It exists only for internal usage by the builders.
func (m *ModeratorMutation) TopicIDs() (ids []int) {
	if id := m.topic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopic resets all changes to the "topic" edge.
func (m *ModeratorMutation) ResetTopic() {
	m.topic = nil
	m.clearedtopic = false
}

// Where appends a list predicates to the ModeratorMutation builder.
func (m *ModeratorMutation) Where(ps ...predicate.Moderator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModeratorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModeratorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Moderator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModeratorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModeratorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Moderator).
func (m *ModeratorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModeratorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.moderator != nil {
		fields = append(fields, moderator.FieldModeratorID)
	}
	if m.topic != nil {
		fields = append(fields, moderator.FieldTopicID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModeratorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moderator.FieldModeratorID:
		return m.ModeratorID()
	case moderator.FieldTopicID:
		return m.TopicID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModeratorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema Moderator does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModeratorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moderator.FieldModeratorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModeratorID(v)
		return nil
	case moderator.FieldTopicID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicID(v)
		return nil
	}
	return fmt.Errorf("unknown Moderator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModeratorMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModeratorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModeratorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Moderator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModeratorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModeratorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModeratorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Moderator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModeratorMutation) ResetField(name string) error {
	switch name {
	case moderator.FieldModeratorID:
		m.ResetModeratorID()
		return nil
	case moderator.FieldTopicID:
		m.ResetTopicID()
		return nil
	}
	return fmt.Errorf("unknown Moderator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModeratorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.moderator != nil {
		edges = append(edges, moderator.EdgeModerator)
	}
	if m.topic != nil {
		edges = append(edges, moderator.EdgeTopic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModeratorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moderator.EdgeModerator:
		if id := m.moderator; id != nil {
			return []ent.Value{*id}
		}
	case moderator.EdgeTopic:
		if id := m.topic; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModeratorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModeratorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModeratorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmoderator {
		edges = append(edges, moderator.EdgeModerator)
	}
	if m.clearedtopic {
		edges = append(edges, moderator.EdgeTopic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModeratorMutation) EdgeCleared(name string) bool {
	switch name {
	case moderator.EdgeModerator:
		return m.clearedmoderator
	case moderator.EdgeTopic:
		return m.clearedtopic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModeratorMutation) ClearEdge(name string) error {
	switch name {
	case moderator.EdgeModerator:
		m.ClearModerator()
		return nil
	case moderator.EdgeTopic:
		m.ClearTopic()
		return nil
	}
	return fmt.Errorf("unknown Moderator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModeratorMutation) ResetEdge(name string) error {
	switch name {
	case moderator.EdgeModerator:
		m.ResetModerator()
		return nil
	case moderator.EdgeTopic:
		m.ResetTopic()
		return nil
	}
	return fmt.Errorf("unknown Moderator edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	tag_name              *string
	clearedFields         map[string]struct{}
	tagged_threads        map[int]struct{}
	removedtagged_threads map[int]struct{}
	clearedtagged_threads bool
	done                  bool
	oldValue              func(context.Context) (*Tag, error)
	predicates            []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagName sets the "tag_name" field.
func (m *TagMutation) SetTagName(s string) {
	m.tag_name = &s
}

// TagName returns the value of the "tag_name" field in the mutation.
func (m *TagMutation) TagName() (r string, exists bool) {
	v := m.tag_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTagName returns the old "tag_name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTagName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagName: %w", err)
	}
	return oldValue.TagName, nil
}

// ResetTagName resets all changes to the "tag_name" field.
func (m *TagMutation) ResetTagName() {
	m.tag_name = nil
}

// AddTaggedThreadIDs adds the "tagged_threads" edge to the Thread entity by ids.
func (m *TagMutation) AddTaggedThreadIDs(ids ...int) {
	if m.tagged_threads == nil {
		m.tagged_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.tagged_threads[ids[i]] = struct{}{}
	}
}

// ClearTaggedThreads clears the "tagged_threads" edge to the Thread entity.
func (m *TagMutation) ClearTaggedThreads() {
	m.clearedtagged_threads = true
}

// TaggedThreadsCleared reports if the "tagged_threads" edge to the Thread entity was cleared.
func (m *TagMutation) TaggedThreadsCleared() bool {
	return m.clearedtagged_threads
}

// RemoveTaggedThreadIDs removes the "tagged_threads" edge to the Thread entity by IDs.
func (m *TagMutation) RemoveTaggedThreadIDs(ids ...int) {
	if m.removedtagged_threads == nil {
		m.removedtagged_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tagged_threads, ids[i])
		m.removedtagged_threads[ids[i]] = struct{}{}
	}
}

// RemovedTaggedThreads returns the removed IDs of the "tagged_threads" edge to the Thread entity.
func (m *TagMutation) RemovedTaggedThreadsIDs() (ids []int) {
	for id := range m.removedtagged_threads {
		ids = append(ids, id)
	}
	return
}

// TaggedThreadsIDs returns the "tagged_threads" edge IDs in the mutation.
func (m *TagMutation) TaggedThreadsIDs() (ids []int) {
	for id := range m.tagged_threads {
		ids = append(ids, id)
	}
	return
}

// ResetTaggedThreads resets all changes to the "tagged_threads" edge.
func (m *TagMutation) ResetTaggedThreads() {
	m.tagged_threads = nil
	m.clearedtagged_threads = false
	m.removedtagged_threads = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tag_name != nil {
		fields = append(fields, tag.FieldTagName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldTagName:
		return m.TagName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldTagName:
		return m.OldTagName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldTagName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldTagName:
		m.ResetTagName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tagged_threads != nil {
		edges = append(edges, tag.EdgeTaggedThreads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTaggedThreads:
		ids := make([]ent.Value, 0, len(m.tagged_threads))
		for id := range m.tagged_threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtagged_threads != nil {
		edges = append(edges, tag.EdgeTaggedThreads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTaggedThreads:
		ids := make([]ent.Value, 0, len(m.removedtagged_threads))
		for id := range m.removedtagged_threads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtagged_threads {
		edges = append(edges, tag.EdgeTaggedThreads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeTaggedThreads:
		return m.clearedtagged_threads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeTaggedThreads:
		m.ResetTaggedThreads()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// ThreadMutation represents an operation that mutates the Thread nodes in the graph.
type ThreadMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	title                  *string
	slug                   *string
	description            *string
	modified_at            *time.Time
	created_at             *time.Time
	clearedFields          map[string]struct{}
	thread_comments        map[int]struct{}
	removedthread_comments map[int]struct{}
	clearedthread_comments bool
	tags                   map[int]struct{}
	removedtags            map[int]struct{}
	clearedtags            bool
	topics                 *int
	clearedtopics          bool
	users                  *uuid.UUID
	clearedusers           bool
	kudoed_users           map[uuid.UUID]struct{}
	removedkudoed_users    map[uuid.UUID]struct{}
	clearedkudoed_users    bool
	done                   bool
	oldValue               func(context.Context) (*Thread, error)
	predicates             []predicate.Thread
}

var _ ent.Mutation = (*ThreadMutation)(nil)

// threadOption allows management of the mutation configuration using functional options.
type threadOption func(*ThreadMutation)

// newThreadMutation creates new mutation for the Thread entity.
func newThreadMutation(c config, op Op, opts ...threadOption) *ThreadMutation {
	m := &ThreadMutation{
		config:        c,
		op:            op,
		typ:           TypeThread,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreadID sets the ID field of the mutation.
func withThreadID(id int) threadOption {
	return func(m *ThreadMutation) {
		var (
			err   error
			once  sync.Once
			value *Thread
		)
		m.oldValue = func(ctx context.Context) (*Thread, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Thread.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThread sets the old Thread of the mutation.
func withThread(node *Thread) threadOption {
	return func(m *ThreadMutation) {
		m.oldValue = func(context.Context) (*Thread, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Thread.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ThreadMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ThreadMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ThreadMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *ThreadMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ThreadMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ThreadMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *ThreadMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ThreadMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ThreadMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[thread.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ThreadMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[thread.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ThreadMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, thread.FieldDescription)
}

// SetModifiedAt sets the "modified_at" field.
func (m *ThreadMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *ThreadMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldModifiedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (m *ThreadMutation) ClearModifiedAt() {
	m.modified_at = nil
	m.clearedFields[thread.FieldModifiedAt] = struct{}{}
}

// ModifiedAtCleared returns if the "modified_at" field was cleared in this mutation.
func (m *ThreadMutation) ModifiedAtCleared() bool {
	_, ok := m.clearedFields[thread.FieldModifiedAt]
	return ok
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *ThreadMutation) ResetModifiedAt() {
	m.modified_at = nil
	delete(m.clearedFields, thread.FieldModifiedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *ThreadMutation) SetCreatedBy(u uuid.UUID) {
	m.users = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ThreadMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ThreadMutation) ResetCreatedBy() {
	m.users = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ThreadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ThreadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Thread entity.
// If the Thread object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ThreadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddThreadCommentIDs adds the "thread_comments" edge to the Comment entity by ids.
func (m *ThreadMutation) AddThreadCommentIDs(ids ...int) {
	if m.thread_comments == nil {
		m.thread_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.thread_comments[ids[i]] = struct{}{}
	}
}

// ClearThreadComments clears the "thread_comments" edge to the Comment entity.
func (m *ThreadMutation) ClearThreadComments() {
	m.clearedthread_comments = true
}

// ThreadCommentsCleared reports if the "thread_comments" edge to the Comment entity was cleared.
func (m *ThreadMutation) ThreadCommentsCleared() bool {
	return m.clearedthread_comments
}

// RemoveThreadCommentIDs removes the "thread_comments" edge to the Comment entity by IDs.
func (m *ThreadMutation) RemoveThreadCommentIDs(ids ...int) {
	if m.removedthread_comments == nil {
		m.removedthread_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.thread_comments, ids[i])
		m.removedthread_comments[ids[i]] = struct{}{}
	}
}

// RemovedThreadComments returns the removed IDs of the "thread_comments" edge to the Comment entity.
func (m *ThreadMutation) RemovedThreadCommentsIDs() (ids []int) {
	for id := range m.removedthread_comments {
		ids = append(ids, id)
	}
	return
}

// ThreadCommentsIDs returns the "thread_comments" edge IDs in the mutation.
func (m *ThreadMutation) ThreadCommentsIDs() (ids []int) {
	for id := range m.thread_comments {
		ids = append(ids, id)
	}
	return
}

// ResetThreadComments resets all changes to the "thread_comments" edge.
func (m *ThreadMutation) ResetThreadComments() {
	m.thread_comments = nil
	m.clearedthread_comments = false
	m.removedthread_comments = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ThreadMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ThreadMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ThreadMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ThreadMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ThreadMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ThreadMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ThreadMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// SetTopicsID sets the "topics" edge to the Topic entity by id.
func (m *ThreadMutation) SetTopicsID(id int) {
	m.topics = &id
}

// ClearTopics clears the "topics" edge to the Topic entity.
func (m *ThreadMutation) ClearTopics() {
	m.clearedtopics = true
}

// TopicsCleared reports if the "topics" edge to the Topic entity was cleared.
func (m *ThreadMutation) TopicsCleared() bool {
	return m.clearedtopics
}

// TopicsID returns the "topics" edge ID in the mutation.
func (m *ThreadMutation) TopicsID() (id int, exists bool) {
	if m.topics != nil {
		return *m.topics, true
	}
	return
}

// TopicsIDs returns the "topics" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TopicsID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) TopicsIDs() (ids []int) {
	if id := m.topics; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTopics resets all changes to the "topics" edge.
func (m *ThreadMutation) ResetTopics() {
	m.topics = nil
	m.clearedtopics = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *ThreadMutation) SetUsersID(id uuid.UUID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ThreadMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[thread.FieldCreatedBy] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ThreadMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *ThreadMutation) UsersID() (id uuid.UUID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *ThreadMutation) UsersIDs() (ids []uuid.UUID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ThreadMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// AddKudoedUserIDs adds the "kudoed_users" edge to the User entity by ids.
func (m *ThreadMutation) AddKudoedUserIDs(ids ...uuid.UUID) {
	if m.kudoed_users == nil {
		m.kudoed_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.kudoed_users[ids[i]] = struct{}{}
	}
}

// ClearKudoedUsers clears the "kudoed_users" edge to the User entity.
func (m *ThreadMutation) ClearKudoedUsers() {
	m.clearedkudoed_users = true
}

// KudoedUsersCleared reports if the "kudoed_users" edge to the User entity was cleared.
func (m *ThreadMutation) KudoedUsersCleared() bool {
	return m.clearedkudoed_users
}

// RemoveKudoedUserIDs removes the "kudoed_users" edge to the User entity by IDs.
func (m *ThreadMutation) RemoveKudoedUserIDs(ids ...uuid.UUID) {
	if m.removedkudoed_users == nil {
		m.removedkudoed_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.kudoed_users, ids[i])
		m.removedkudoed_users[ids[i]] = struct{}{}
	}
}

// RemovedKudoedUsers returns the removed IDs of the "kudoed_users" edge to the User entity.
func (m *ThreadMutation) RemovedKudoedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedkudoed_users {
		ids = append(ids, id)
	}
	return
}

// KudoedUsersIDs returns the "kudoed_users" edge IDs in the mutation.
func (m *ThreadMutation) KudoedUsersIDs() (ids []uuid.UUID) {
	for id := range m.kudoed_users {
		ids = append(ids, id)
	}
	return
}

// ResetKudoedUsers resets all changes to the "kudoed_users" edge.
func (m *ThreadMutation) ResetKudoedUsers() {
	m.kudoed_users = nil
	m.clearedkudoed_users = false
	m.removedkudoed_users = nil
}

// Where appends a list predicates to the ThreadMutation builder.
func (m *ThreadMutation) Where(ps ...predicate.Thread) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Thread, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Thread).
func (m *ThreadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, thread.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, thread.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, thread.FieldDescription)
	}
	if m.modified_at != nil {
		fields = append(fields, thread.FieldModifiedAt)
	}
	if m.users != nil {
		fields = append(fields, thread.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, thread.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case thread.FieldTitle:
		return m.Title()
	case thread.FieldSlug:
		return m.Slug()
	case thread.FieldDescription:
		return m.Description()
	case thread.FieldModifiedAt:
		return m.ModifiedAt()
	case thread.FieldCreatedBy:
		return m.CreatedBy()
	case thread.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case thread.FieldTitle:
		return m.OldTitle(ctx)
	case thread.FieldSlug:
		return m.OldSlug(ctx)
	case thread.FieldDescription:
		return m.OldDescription(ctx)
	case thread.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	case thread.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case thread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Thread field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case thread.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case thread.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case thread.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case thread.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case thread.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case thread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Thread numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(thread.FieldDescription) {
		fields = append(fields, thread.FieldDescription)
	}
	if m.FieldCleared(thread.FieldModifiedAt) {
		fields = append(fields, thread.FieldModifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadMutation) ClearField(name string) error {
	switch name {
	case thread.FieldDescription:
		m.ClearDescription()
		return nil
	case thread.FieldModifiedAt:
		m.ClearModifiedAt()
		return nil
	}
	return fmt.Errorf("unknown Thread nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadMutation) ResetField(name string) error {
	switch name {
	case thread.FieldTitle:
		m.ResetTitle()
		return nil
	case thread.FieldSlug:
		m.ResetSlug()
		return nil
	case thread.FieldDescription:
		m.ResetDescription()
		return nil
	case thread.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case thread.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case thread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Thread field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.thread_comments != nil {
		edges = append(edges, thread.EdgeThreadComments)
	}
	if m.tags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.topics != nil {
		edges = append(edges, thread.EdgeTopics)
	}
	if m.users != nil {
		edges = append(edges, thread.EdgeUsers)
	}
	if m.kudoed_users != nil {
		edges = append(edges, thread.EdgeKudoedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeThreadComments:
		ids := make([]ent.Value, 0, len(m.thread_comments))
		for id := range m.thread_comments {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTopics:
		if id := m.topics; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case thread.EdgeKudoedUsers:
		ids := make([]ent.Value, 0, len(m.kudoed_users))
		for id := range m.kudoed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedthread_comments != nil {
		edges = append(edges, thread.EdgeThreadComments)
	}
	if m.removedtags != nil {
		edges = append(edges, thread.EdgeTags)
	}
	if m.removedkudoed_users != nil {
		edges = append(edges, thread.EdgeKudoedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case thread.EdgeThreadComments:
		ids := make([]ent.Value, 0, len(m.removedthread_comments))
		for id := range m.removedthread_comments {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case thread.EdgeKudoedUsers:
		ids := make([]ent.Value, 0, len(m.removedkudoed_users))
		for id := range m.removedkudoed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedthread_comments {
		edges = append(edges, thread.EdgeThreadComments)
	}
	if m.clearedtags {
		edges = append(edges, thread.EdgeTags)
	}
	if m.clearedtopics {
		edges = append(edges, thread.EdgeTopics)
	}
	if m.clearedusers {
		edges = append(edges, thread.EdgeUsers)
	}
	if m.clearedkudoed_users {
		edges = append(edges, thread.EdgeKudoedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadMutation) EdgeCleared(name string) bool {
	switch name {
	case thread.EdgeThreadComments:
		return m.clearedthread_comments
	case thread.EdgeTags:
		return m.clearedtags
	case thread.EdgeTopics:
		return m.clearedtopics
	case thread.EdgeUsers:
		return m.clearedusers
	case thread.EdgeKudoedUsers:
		return m.clearedkudoed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadMutation) ClearEdge(name string) error {
	switch name {
	case thread.EdgeTopics:
		m.ClearTopics()
		return nil
	case thread.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Thread unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadMutation) ResetEdge(name string) error {
	switch name {
	case thread.EdgeThreadComments:
		m.ResetThreadComments()
		return nil
	case thread.EdgeTags:
		m.ResetTags()
		return nil
	case thread.EdgeTopics:
		m.ResetTopics()
		return nil
	case thread.EdgeUsers:
		m.ResetUsers()
		return nil
	case thread.EdgeKudoedUsers:
		m.ResetKudoedUsers()
		return nil
	}
	return fmt.Errorf("unknown Thread edge %s", name)
}

// ThreadKudoMutation represents an operation that mutates the ThreadKudo nodes in the graph.
type ThreadKudoMutation struct {
	config
	op            Op
	typ           string
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	thread        *int
	clearedthread bool
	done          bool
	oldValue      func(context.Context) (*ThreadKudo, error)
	predicates    []predicate.ThreadKudo
}

var _ ent.Mutation = (*ThreadKudoMutation)(nil)

// threadkudoOption allows management of the mutation configuration using functional options.
type threadkudoOption func(*ThreadKudoMutation)

// newThreadKudoMutation creates new mutation for the ThreadKudo entity.
func newThreadKudoMutation(c config, op Op, opts ...threadkudoOption) *ThreadKudoMutation {
	m := &ThreadKudoMutation{
		config:        c,
		op:            op,
		typ:           TypeThreadKudo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreadKudoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreadKudoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *ThreadKudoMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ThreadKudoMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ThreadKudoMutation) ResetUserID() {
	m.user = nil
}

// SetThreadID sets the "thread_id" field.
func (m *ThreadKudoMutation) SetThreadID(i int) {
	m.thread = &i
}

// ThreadID returns the value of the "thread_id" field in the mutation.
func (m *ThreadKudoMutation) ThreadID() (r int, exists bool) {
	v := m.thread
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreadID resets all changes to the "thread_id" field.
func (m *ThreadKudoMutation) ResetThreadID() {
	m.thread = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ThreadKudoMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[threadkudo.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ThreadKudoMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ThreadKudoMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ThreadKudoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearThread clears the "thread" edge to the Thread entity.
func (m *ThreadKudoMutation) ClearThread() {
	m.clearedthread = true
	m.clearedFields[threadkudo.FieldThreadID] = struct{}{}
}

// ThreadCleared reports if the "thread" edge to the Thread entity was cleared.
func (m *ThreadKudoMutation) ThreadCleared() bool {
	return m.clearedthread
}

// ThreadIDs returns the "thread" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ThreadID instead. It exists only for internal usage by the builders.
func (m *ThreadKudoMutation) ThreadIDs() (ids []int) {
	if id := m.thread; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetThread resets all changes to the "thread" edge.
func (m *ThreadKudoMutation) ResetThread() {
	m.thread = nil
	m.clearedthread = false
}

// Where appends a list predicates to the ThreadKudoMutation builder.
func (m *ThreadKudoMutation) Where(ps ...predicate.ThreadKudo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ThreadKudoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ThreadKudoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ThreadKudo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ThreadKudoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ThreadKudoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ThreadKudo).
func (m *ThreadKudoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreadKudoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user != nil {
		fields = append(fields, threadkudo.FieldUserID)
	}
	if m.thread != nil {
		fields = append(fields, threadkudo.FieldThreadID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreadKudoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threadkudo.FieldUserID:
		return m.UserID()
	case threadkudo.FieldThreadID:
		return m.ThreadID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreadKudoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema ThreadKudo does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadKudoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threadkudo.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case threadkudo.FieldThreadID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreadID(v)
		return nil
	}
	return fmt.Errorf("unknown ThreadKudo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreadKudoMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreadKudoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreadKudoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ThreadKudo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreadKudoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreadKudoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreadKudoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreadKudo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreadKudoMutation) ResetField(name string) error {
	switch name {
	case threadkudo.FieldUserID:
		m.ResetUserID()
		return nil
	case threadkudo.FieldThreadID:
		m.ResetThreadID()
		return nil
	}
	return fmt.Errorf("unknown ThreadKudo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreadKudoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, threadkudo.EdgeUser)
	}
	if m.thread != nil {
		edges = append(edges, threadkudo.EdgeThread)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreadKudoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threadkudo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case threadkudo.EdgeThread:
		if id := m.thread; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreadKudoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreadKudoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreadKudoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, threadkudo.EdgeUser)
	}
	if m.clearedthread {
		edges = append(edges, threadkudo.EdgeThread)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreadKudoMutation) EdgeCleared(name string) bool {
	switch name {
	case threadkudo.EdgeUser:
		return m.cleareduser
	case threadkudo.EdgeThread:
		return m.clearedthread
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreadKudoMutation) ClearEdge(name string) error {
	switch name {
	case threadkudo.EdgeUser:
		m.ClearUser()
		return nil
	case threadkudo.EdgeThread:
		m.ClearThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadKudo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreadKudoMutation) ResetEdge(name string) error {
	switch name {
	case threadkudo.EdgeUser:
		m.ResetUser()
		return nil
	case threadkudo.EdgeThread:
		m.ResetThread()
		return nil
	}
	return fmt.Errorf("unknown ThreadKudo edge %s", name)
}

// TopicMutation represents an operation that mutates the Topic nodes in the graph.
type TopicMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	title                   *string
	slug                    *string
	short_description       *string
	description             *string
	profile_pic_url         *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	topic_threads           map[int]struct{}
	removedtopic_threads    map[int]struct{}
	clearedtopic_threads    bool
	topic_moderators        map[uuid.UUID]struct{}
	removedtopic_moderators map[uuid.UUID]struct{}
	clearedtopic_moderators bool
	done                    bool
	oldValue                func(context.Context) (*Topic, error)
	predicates              []predicate.Topic
}

var _ ent.Mutation = (*TopicMutation)(nil)

// topicOption allows management of the mutation configuration using functional options.
type topicOption func(*TopicMutation)

// newTopicMutation creates new mutation for the Topic entity.
func newTopicMutation(c config, op Op, opts ...topicOption) *TopicMutation {
	m := &TopicMutation{
		config:        c,
		op:            op,
		typ:           TypeTopic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTopicID sets the ID field of the mutation.
func withTopicID(id int) topicOption {
	return func(m *TopicMutation) {
		var (
			err   error
			once  sync.Once
			value *Topic
		)
		m.oldValue = func(ctx context.Context) (*Topic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Topic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTopic sets the old Topic of the mutation.
func withTopic(node *Topic) topicOption {
	return func(m *TopicMutation) {
		m.oldValue = func(context.Context) (*Topic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TopicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TopicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TopicMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TopicMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Topic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *TopicMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TopicMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TopicMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *TopicMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TopicMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TopicMutation) ResetSlug() {
	m.slug = nil
}

// SetShortDescription sets the "short_description" field.
func (m *TopicMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *TopicMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *TopicMutation) ResetShortDescription() {
	m.short_description = nil
}

// SetDescription sets the "description" field.
func (m *TopicMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TopicMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TopicMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[topic.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TopicMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[topic.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TopicMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, topic.FieldDescription)
}

// SetProfilePicURL sets the "profile_pic_url" field.
func (m *TopicMutation) SetProfilePicURL(s string) {
	m.profile_pic_url = &s
}

// ProfilePicURL returns the value of the "profile_pic_url" field in the mutation.
func (m *TopicMutation) ProfilePicURL() (r string, exists bool) {
	v := m.profile_pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePicURL returns the old "profile_pic_url" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldProfilePicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePicURL: %w", err)
	}
	return oldValue.ProfilePicURL, nil
}

// ClearProfilePicURL clears the value of the "profile_pic_url" field.
func (m *TopicMutation) ClearProfilePicURL() {
	m.profile_pic_url = nil
	m.clearedFields[topic.FieldProfilePicURL] = struct{}{}
}

// ProfilePicURLCleared returns if the "profile_pic_url" field was cleared in this mutation.
func (m *TopicMutation) ProfilePicURLCleared() bool {
	_, ok := m.clearedFields[topic.FieldProfilePicURL]
	return ok
}

// ResetProfilePicURL resets all changes to the "profile_pic_url" field.
func (m *TopicMutation) ResetProfilePicURL() {
	m.profile_pic_url = nil
	delete(m.clearedFields, topic.FieldProfilePicURL)
}

// SetCreatedAt sets the "created_at" field.
func (m *TopicMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TopicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Topic entity.
// If the Topic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TopicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TopicMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddTopicThreadIDs adds the "topic_threads" edge to the Thread entity by ids.
func (m *TopicMutation) AddTopicThreadIDs(ids ...int) {
	if m.topic_threads == nil {
		m.topic_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.topic_threads[ids[i]] = struct{}{}
	}
}

// ClearTopicThreads clears the "topic_threads" edge to the Thread entity.
func (m *TopicMutation) ClearTopicThreads() {
	m.clearedtopic_threads = true
}

// TopicThreadsCleared reports if the "topic_threads" edge to the Thread entity was cleared.
func (m *TopicMutation) TopicThreadsCleared() bool {
	return m.clearedtopic_threads
}

// RemoveTopicThreadIDs removes the "topic_threads" edge to the Thread entity by IDs.
func (m *TopicMutation) RemoveTopicThreadIDs(ids ...int) {
	if m.removedtopic_threads == nil {
		m.removedtopic_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.topic_threads, ids[i])
		m.removedtopic_threads[ids[i]] = struct{}{}
	}
}

// RemovedTopicThreads returns the removed IDs of the "topic_threads" edge to the Thread entity.
func (m *TopicMutation) RemovedTopicThreadsIDs() (ids []int) {
	for id := range m.removedtopic_threads {
		ids = append(ids, id)
	}
	return
}

// TopicThreadsIDs returns the "topic_threads" edge IDs in the mutation.
func (m *TopicMutation) TopicThreadsIDs() (ids []int) {
	for id := range m.topic_threads {
		ids = append(ids, id)
	}
	return
}

// ResetTopicThreads resets all changes to the "topic_threads" edge.
func (m *TopicMutation) ResetTopicThreads() {
	m.topic_threads = nil
	m.clearedtopic_threads = false
	m.removedtopic_threads = nil
}

// AddTopicModeratorIDs adds the "topic_moderators" edge to the User entity by ids.
func (m *TopicMutation) AddTopicModeratorIDs(ids ...uuid.UUID) {
	if m.topic_moderators == nil {
		m.topic_moderators = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.topic_moderators[ids[i]] = struct{}{}
	}
}

// ClearTopicModerators clears the "topic_moderators" edge to the User entity.
func (m *TopicMutation) ClearTopicModerators() {
	m.clearedtopic_moderators = true
}

// TopicModeratorsCleared reports if the "topic_moderators" edge to the User entity was cleared.
func (m *TopicMutation) TopicModeratorsCleared() bool {
	return m.clearedtopic_moderators
}

// RemoveTopicModeratorIDs removes the "topic_moderators" edge to the User entity by IDs.
func (m *TopicMutation) RemoveTopicModeratorIDs(ids ...uuid.UUID) {
	if m.removedtopic_moderators == nil {
		m.removedtopic_moderators = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.topic_moderators, ids[i])
		m.removedtopic_moderators[ids[i]] = struct{}{}
	}
}

// RemovedTopicModerators returns the removed IDs of the "topic_moderators" edge to the User entity.
func (m *TopicMutation) RemovedTopicModeratorsIDs() (ids []uuid.UUID) {
	for id := range m.removedtopic_moderators {
		ids = append(ids, id)
	}
	return
}

// TopicModeratorsIDs returns the "topic_moderators" edge IDs in the mutation.
func (m *TopicMutation) TopicModeratorsIDs() (ids []uuid.UUID) {
	for id := range m.topic_moderators {
		ids = append(ids, id)
	}
	return
}

// ResetTopicModerators resets all changes to the "topic_moderators" edge.
func (m *TopicMutation) ResetTopicModerators() {
	m.topic_moderators = nil
	m.clearedtopic_moderators = false
	m.removedtopic_moderators = nil
}

// Where appends a list predicates to the TopicMutation builder.
func (m *TopicMutation) Where(ps ...predicate.Topic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TopicMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TopicMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Topic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TopicMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TopicMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Topic).
func (m *TopicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TopicMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, topic.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, topic.FieldSlug)
	}
	if m.short_description != nil {
		fields = append(fields, topic.FieldShortDescription)
	}
	if m.description != nil {
		fields = append(fields, topic.FieldDescription)
	}
	if m.profile_pic_url != nil {
		fields = append(fields, topic.FieldProfilePicURL)
	}
	if m.created_at != nil {
		fields = append(fields, topic.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TopicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case topic.FieldTitle:
		return m.Title()
	case topic.FieldSlug:
		return m.Slug()
	case topic.FieldShortDescription:
		return m.ShortDescription()
	case topic.FieldDescription:
		return m.Description()
	case topic.FieldProfilePicURL:
		return m.ProfilePicURL()
	case topic.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TopicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case topic.FieldTitle:
		return m.OldTitle(ctx)
	case topic.FieldSlug:
		return m.OldSlug(ctx)
	case topic.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case topic.FieldDescription:
		return m.OldDescription(ctx)
	case topic.FieldProfilePicURL:
		return m.OldProfilePicURL(ctx)
	case topic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Topic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case topic.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case topic.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case topic.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case topic.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case topic.FieldProfilePicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePicURL(v)
		return nil
	case topic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TopicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TopicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TopicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TopicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(topic.FieldDescription) {
		fields = append(fields, topic.FieldDescription)
	}
	if m.FieldCleared(topic.FieldProfilePicURL) {
		fields = append(fields, topic.FieldProfilePicURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TopicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TopicMutation) ClearField(name string) error {
	switch name {
	case topic.FieldDescription:
		m.ClearDescription()
		return nil
	case topic.FieldProfilePicURL:
		m.ClearProfilePicURL()
		return nil
	}
	return fmt.Errorf("unknown Topic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TopicMutation) ResetField(name string) error {
	switch name {
	case topic.FieldTitle:
		m.ResetTitle()
		return nil
	case topic.FieldSlug:
		m.ResetSlug()
		return nil
	case topic.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case topic.FieldDescription:
		m.ResetDescription()
		return nil
	case topic.FieldProfilePicURL:
		m.ResetProfilePicURL()
		return nil
	case topic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Topic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TopicMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.topic_threads != nil {
		edges = append(edges, topic.EdgeTopicThreads)
	}
	if m.topic_moderators != nil {
		edges = append(edges, topic.EdgeTopicModerators)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TopicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeTopicThreads:
		ids := make([]ent.Value, 0, len(m.topic_threads))
		for id := range m.topic_threads {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeTopicModerators:
		ids := make([]ent.Value, 0, len(m.topic_moderators))
		for id := range m.topic_moderators {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TopicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtopic_threads != nil {
		edges = append(edges, topic.EdgeTopicThreads)
	}
	if m.removedtopic_moderators != nil {
		edges = append(edges, topic.EdgeTopicModerators)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TopicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case topic.EdgeTopicThreads:
		ids := make([]ent.Value, 0, len(m.removedtopic_threads))
		for id := range m.removedtopic_threads {
			ids = append(ids, id)
		}
		return ids
	case topic.EdgeTopicModerators:
		ids := make([]ent.Value, 0, len(m.removedtopic_moderators))
		for id := range m.removedtopic_moderators {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TopicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtopic_threads {
		edges = append(edges, topic.EdgeTopicThreads)
	}
	if m.clearedtopic_moderators {
		edges = append(edges, topic.EdgeTopicModerators)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TopicMutation) EdgeCleared(name string) bool {
	switch name {
	case topic.EdgeTopicThreads:
		return m.clearedtopic_threads
	case topic.EdgeTopicModerators:
		return m.clearedtopic_moderators
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TopicMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Topic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TopicMutation) ResetEdge(name string) error {
	switch name {
	case topic.EdgeTopicThreads:
		m.ResetTopicThreads()
		return nil
	case topic.EdgeTopicModerators:
		m.ResetTopicModerators()
		return nil
	}
	return fmt.Errorf("unknown Topic edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	email                   *string
	username                *string
	first_name              *string
	last_name               *string
	hash                    *string
	salt                    *string
	email_verified          *bool
	created_at              *time.Time
	clearedFields           map[string]struct{}
	user_threads            map[int]struct{}
	removeduser_threads     map[int]struct{}
	cleareduser_threads     bool
	kudoed_threads          map[int]struct{}
	removedkudoed_threads   map[int]struct{}
	clearedkudoed_threads   bool
	user_comments           map[int]struct{}
	removeduser_comments    map[int]struct{}
	cleareduser_comments    bool
	kudoed_comments         map[int]struct{}
	removedkudoed_comments  map[int]struct{}
	clearedkudoed_comments  bool
	moderated_topics        map[int]struct{}
	removedmoderated_topics map[int]struct{}
	clearedmoderated_topics bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetHash sets the "hash" field.
func (m *UserMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *UserMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ClearHash clears the value of the "hash" field.
func (m *UserMutation) ClearHash() {
	m.hash = nil
	m.clearedFields[user.FieldHash] = struct{}{}
}

// HashCleared returns if the "hash" field was cleared in this mutation.
func (m *UserMutation) HashCleared() bool {
	_, ok := m.clearedFields[user.FieldHash]
	return ok
}

// ResetHash resets all changes to the "hash" field.
func (m *UserMutation) ResetHash() {
	m.hash = nil
	delete(m.clearedFields, user.FieldHash)
}

// SetSalt sets the "salt" field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the value of the "salt" field in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ClearSalt clears the value of the "salt" field.
func (m *UserMutation) ClearSalt() {
	m.salt = nil
	m.clearedFields[user.FieldSalt] = struct{}{}
}

// SaltCleared returns if the "salt" field was cleared in this mutation.
func (m *UserMutation) SaltCleared() bool {
	_, ok := m.clearedFields[user.FieldSalt]
	return ok
}

// ResetSalt resets all changes to the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
	delete(m.clearedFields, user.FieldSalt)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserThreadIDs adds the "user_threads" edge to the Thread entity by ids.
func (m *UserMutation) AddUserThreadIDs(ids ...int) {
	if m.user_threads == nil {
		m.user_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.user_threads[ids[i]] = struct{}{}
	}
}

// ClearUserThreads clears the "user_threads" edge to the Thread entity.
func (m *UserMutation) ClearUserThreads() {
	m.cleareduser_threads = true
}

// UserThreadsCleared reports if the "user_threads" edge to the Thread entity was cleared.
func (m *UserMutation) UserThreadsCleared() bool {
	return m.cleareduser_threads
}

// RemoveUserThreadIDs removes the "user_threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveUserThreadIDs(ids ...int) {
	if m.removeduser_threads == nil {
		m.removeduser_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_threads, ids[i])
		m.removeduser_threads[ids[i]] = struct{}{}
	}
}

// RemovedUserThreads returns the removed IDs of the "user_threads" edge to the Thread entity.
func (m *UserMutation) RemovedUserThreadsIDs() (ids []int) {
	for id := range m.removeduser_threads {
		ids = append(ids, id)
	}
	return
}

// UserThreadsIDs returns the "user_threads" edge IDs in the mutation.
func (m *UserMutation) UserThreadsIDs() (ids []int) {
	for id := range m.user_threads {
		ids = append(ids, id)
	}
	return
}

// ResetUserThreads resets all changes to the "user_threads" edge.
func (m *UserMutation) ResetUserThreads() {
	m.user_threads = nil
	m.cleareduser_threads = false
	m.removeduser_threads = nil
}

// AddKudoedThreadIDs adds the "kudoed_threads" edge to the Thread entity by ids.
func (m *UserMutation) AddKudoedThreadIDs(ids ...int) {
	if m.kudoed_threads == nil {
		m.kudoed_threads = make(map[int]struct{})
	}
	for i := range ids {
		m.kudoed_threads[ids[i]] = struct{}{}
	}
}

// ClearKudoedThreads clears the "kudoed_threads" edge to the Thread entity.
func (m *UserMutation) ClearKudoedThreads() {
	m.clearedkudoed_threads = true
}

// KudoedThreadsCleared reports if the "kudoed_threads" edge to the Thread entity was cleared.
func (m *UserMutation) KudoedThreadsCleared() bool {
	return m.clearedkudoed_threads
}

// RemoveKudoedThreadIDs removes the "kudoed_threads" edge to the Thread entity by IDs.
func (m *UserMutation) RemoveKudoedThreadIDs(ids ...int) {
	if m.removedkudoed_threads == nil {
		m.removedkudoed_threads = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.kudoed_threads, ids[i])
		m.removedkudoed_threads[ids[i]] = struct{}{}
	}
}

// RemovedKudoedThreads returns the removed IDs of the "kudoed_threads" edge to the Thread entity.
func (m *UserMutation) RemovedKudoedThreadsIDs() (ids []int) {
	for id := range m.removedkudoed_threads {
		ids = append(ids, id)
	}
	return
}

// KudoedThreadsIDs returns the "kudoed_threads" edge IDs in the mutation.
func (m *UserMutation) KudoedThreadsIDs() (ids []int) {
	for id := range m.kudoed_threads {
		ids = append(ids, id)
	}
	return
}

// ResetKudoedThreads resets all changes to the "kudoed_threads" edge.
func (m *UserMutation) ResetKudoedThreads() {
	m.kudoed_threads = nil
	m.clearedkudoed_threads = false
	m.removedkudoed_threads = nil
}

// AddUserCommentIDs adds the "user_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddUserCommentIDs(ids ...int) {
	if m.user_comments == nil {
		m.user_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.user_comments[ids[i]] = struct{}{}
	}
}

// ClearUserComments clears the "user_comments" edge to the Comment entity.
func (m *UserMutation) ClearUserComments() {
	m.cleareduser_comments = true
}

// UserCommentsCleared reports if the "user_comments" edge to the Comment entity was cleared.
func (m *UserMutation) UserCommentsCleared() bool {
	return m.cleareduser_comments
}

// RemoveUserCommentIDs removes the "user_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveUserCommentIDs(ids ...int) {
	if m.removeduser_comments == nil {
		m.removeduser_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_comments, ids[i])
		m.removeduser_comments[ids[i]] = struct{}{}
	}
}

// RemovedUserComments returns the removed IDs of the "user_comments" edge to the Comment entity.
func (m *UserMutation) RemovedUserCommentsIDs() (ids []int) {
	for id := range m.removeduser_comments {
		ids = append(ids, id)
	}
	return
}

// UserCommentsIDs returns the "user_comments" edge IDs in the mutation.
func (m *UserMutation) UserCommentsIDs() (ids []int) {
	for id := range m.user_comments {
		ids = append(ids, id)
	}
	return
}

// ResetUserComments resets all changes to the "user_comments" edge.
func (m *UserMutation) ResetUserComments() {
	m.user_comments = nil
	m.cleareduser_comments = false
	m.removeduser_comments = nil
}

// AddKudoedCommentIDs adds the "kudoed_comments" edge to the Comment entity by ids.
func (m *UserMutation) AddKudoedCommentIDs(ids ...int) {
	if m.kudoed_comments == nil {
		m.kudoed_comments = make(map[int]struct{})
	}
	for i := range ids {
		m.kudoed_comments[ids[i]] = struct{}{}
	}
}

// ClearKudoedComments clears the "kudoed_comments" edge to the Comment entity.
func (m *UserMutation) ClearKudoedComments() {
	m.clearedkudoed_comments = true
}

// KudoedCommentsCleared reports if the "kudoed_comments" edge to the Comment entity was cleared.
func (m *UserMutation) KudoedCommentsCleared() bool {
	return m.clearedkudoed_comments
}

// RemoveKudoedCommentIDs removes the "kudoed_comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveKudoedCommentIDs(ids ...int) {
	if m.removedkudoed_comments == nil {
		m.removedkudoed_comments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.kudoed_comments, ids[i])
		m.removedkudoed_comments[ids[i]] = struct{}{}
	}
}

// RemovedKudoedComments returns the removed IDs of the "kudoed_comments" edge to the Comment entity.
func (m *UserMutation) RemovedKudoedCommentsIDs() (ids []int) {
	for id := range m.removedkudoed_comments {
		ids = append(ids, id)
	}
	return
}

// KudoedCommentsIDs returns the "kudoed_comments" edge IDs in the mutation.
func (m *UserMutation) KudoedCommentsIDs() (ids []int) {
	for id := range m.kudoed_comments {
		ids = append(ids, id)
	}
	return
}

// ResetKudoedComments resets all changes to the "kudoed_comments" edge.
func (m *UserMutation) ResetKudoedComments() {
	m.kudoed_comments = nil
	m.clearedkudoed_comments = false
	m.removedkudoed_comments = nil
}

// AddModeratedTopicIDs adds the "moderated_topics" edge to the Topic entity by ids.
func (m *UserMutation) AddModeratedTopicIDs(ids ...int) {
	if m.moderated_topics == nil {
		m.moderated_topics = make(map[int]struct{})
	}
	for i := range ids {
		m.moderated_topics[ids[i]] = struct{}{}
	}
}

// ClearModeratedTopics clears the "moderated_topics" edge to the Topic entity.
func (m *UserMutation) ClearModeratedTopics() {
	m.clearedmoderated_topics = true
}

// ModeratedTopicsCleared reports if the "moderated_topics" edge to the Topic entity was cleared.
func (m *UserMutation) ModeratedTopicsCleared() bool {
	return m.clearedmoderated_topics
}

// RemoveModeratedTopicIDs removes the "moderated_topics" edge to the Topic entity by IDs.
func (m *UserMutation) RemoveModeratedTopicIDs(ids ...int) {
	if m.removedmoderated_topics == nil {
		m.removedmoderated_topics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.moderated_topics, ids[i])
		m.removedmoderated_topics[ids[i]] = struct{}{}
	}
}

// RemovedModeratedTopics returns the removed IDs of the "moderated_topics" edge to the Topic entity.
func (m *UserMutation) RemovedModeratedTopicsIDs() (ids []int) {
	for id := range m.removedmoderated_topics {
		ids = append(ids, id)
	}
	return
}

// ModeratedTopicsIDs returns the "moderated_topics" edge IDs in the mutation.
func (m *UserMutation) ModeratedTopicsIDs() (ids []int) {
	for id := range m.moderated_topics {
		ids = append(ids, id)
	}
	return
}

// ResetModeratedTopics resets all changes to the "moderated_topics" edge.
func (m *UserMutation) ResetModeratedTopics() {
	m.moderated_topics = nil
	m.clearedmoderated_topics = false
	m.removedmoderated_topics = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.hash != nil {
		fields = append(fields, user.FieldHash)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldHash:
		return m.Hash()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldHash:
		return m.OldHash(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldHash) {
		fields = append(fields, user.FieldHash)
	}
	if m.FieldCleared(user.FieldSalt) {
		fields = append(fields, user.FieldSalt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldHash:
		m.ClearHash()
		return nil
	case user.FieldSalt:
		m.ClearSalt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldHash:
		m.ResetHash()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user_threads != nil {
		edges = append(edges, user.EdgeUserThreads)
	}
	if m.kudoed_threads != nil {
		edges = append(edges, user.EdgeKudoedThreads)
	}
	if m.user_comments != nil {
		edges = append(edges, user.EdgeUserComments)
	}
	if m.kudoed_comments != nil {
		edges = append(edges, user.EdgeKudoedComments)
	}
	if m.moderated_topics != nil {
		edges = append(edges, user.EdgeModeratedTopics)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserThreads:
		ids := make([]ent.Value, 0, len(m.user_threads))
		for id := range m.user_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeKudoedThreads:
		ids := make([]ent.Value, 0, len(m.kudoed_threads))
		for id := range m.kudoed_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserComments:
		ids := make([]ent.Value, 0, len(m.user_comments))
		for id := range m.user_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeKudoedComments:
		ids := make([]ent.Value, 0, len(m.kudoed_comments))
		for id := range m.kudoed_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModeratedTopics:
		ids := make([]ent.Value, 0, len(m.moderated_topics))
		for id := range m.moderated_topics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeduser_threads != nil {
		edges = append(edges, user.EdgeUserThreads)
	}
	if m.removedkudoed_threads != nil {
		edges = append(edges, user.EdgeKudoedThreads)
	}
	if m.removeduser_comments != nil {
		edges = append(edges, user.EdgeUserComments)
	}
	if m.removedkudoed_comments != nil {
		edges = append(edges, user.EdgeKudoedComments)
	}
	if m.removedmoderated_topics != nil {
		edges = append(edges, user.EdgeModeratedTopics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserThreads:
		ids := make([]ent.Value, 0, len(m.removeduser_threads))
		for id := range m.removeduser_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeKudoedThreads:
		ids := make([]ent.Value, 0, len(m.removedkudoed_threads))
		for id := range m.removedkudoed_threads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserComments:
		ids := make([]ent.Value, 0, len(m.removeduser_comments))
		for id := range m.removeduser_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeKudoedComments:
		ids := make([]ent.Value, 0, len(m.removedkudoed_comments))
		for id := range m.removedkudoed_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModeratedTopics:
		ids := make([]ent.Value, 0, len(m.removedmoderated_topics))
		for id := range m.removedmoderated_topics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser_threads {
		edges = append(edges, user.EdgeUserThreads)
	}
	if m.clearedkudoed_threads {
		edges = append(edges, user.EdgeKudoedThreads)
	}
	if m.cleareduser_comments {
		edges = append(edges, user.EdgeUserComments)
	}
	if m.clearedkudoed_comments {
		edges = append(edges, user.EdgeKudoedComments)
	}
	if m.clearedmoderated_topics {
		edges = append(edges, user.EdgeModeratedTopics)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserThreads:
		return m.cleareduser_threads
	case user.EdgeKudoedThreads:
		return m.clearedkudoed_threads
	case user.EdgeUserComments:
		return m.cleareduser_comments
	case user.EdgeKudoedComments:
		return m.clearedkudoed_comments
	case user.EdgeModeratedTopics:
		return m.clearedmoderated_topics
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserThreads:
		m.ResetUserThreads()
		return nil
	case user.EdgeKudoedThreads:
		m.ResetKudoedThreads()
		return nil
	case user.EdgeUserComments:
		m.ResetUserComments()
		return nil
	case user.EdgeKudoedComments:
		m.ResetKudoedComments()
		return nil
	case user.EdgeModeratedTopics:
		m.ResetModeratedTopics()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
